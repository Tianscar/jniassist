package com.tianscar.jni.assist;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;
import java.util.ArrayList;
import java.util.List;

public final class JNIAssist {

    private static String escapeUTF(String text) {
        StringBuilder builder = new StringBuilder();
        for (char ch : text.toCharArray()) {
            if (ch < 128) builder.append(ch);
            else builder.append("_0").append(Integer.toHexString(ch));
        }
        return builder.toString();
    }

    private static String typeMapping(Class<?> type) {
        if (type == void.class) return "void";
        else if (type == boolean.class) return "jboolean";
        else if (type == byte.class) return "jbyte";
        else if (type == char.class) return "jchar";
        else if (type == short.class) return "jshort";
        else if (type == int.class) return "jint";
        else if (type == long.class) return "jlong";
        else if (type == float.class) return "jfloat";
        else if (type == double.class) return "jdouble";
        else if (type == String.class) return "jstring";
        else if (type.isAssignableFrom(Throwable.class)) return "jthrowable";
        else if (type.isAssignableFrom(Class.class)) return "jclass";
        else if (type.isArray()) {
            type = type.getComponentType();
            if (type == boolean[].class) return "jbooleanArray";
            else if (type == byte[].class) return "jbyteArray";
            else if (type == char[].class) return "jcharArray";
            else if (type == short[].class) return "jshortArray";
            else if (type == int[].class) return "jintArray";
            else if (type == long[].class) return "jlongArray";
            else if (type == float[].class) return "jfloatArray";
            else if (type == double[].class) return "jdoubleArray";
            else return "jobjectArray";
        }
        else return "jobject";
    }

    private static String signature(Class<?> type, boolean escape) {
        if (type.isArray()) return (escape ? "_3" : "[") + signature(type.getComponentType(), escape);
        else if (type == void.class) return "V";
        else if (type == boolean.class) return "Z";
        else if (type == byte.class) return "B";
        else if (type == char.class) return "C";
        else if (type == short.class) return "S";
        else if (type == int.class) return "I";
        else if (type == long.class) return "J";
        else if (type == float.class) return "F";
        else if (type == double.class) return "D";
        else return "L" +
                    escapeUTF(type.getName().replace("_", "_1").replace(".", "_"))
                    + (escape ? "_2" : ";");
    }

    private static String uppercase(Class<?> type) {
        if (type == void.class) return "Void";
        else if (type == boolean.class) return "Boolean";
        else if (type == byte.class) return "Byte";
        else if (type == char.class) return "Char";
        else if (type == short.class) return "Short";
        else if (type == int.class) return "Int";
        else if (type == long.class) return "Long";
        else if (type == float.class) return "Float";
        else if (type == double.class) return "Double";
        else return "Object";
    }

    private static String signature(Method method) {
        StringBuilder builder = new StringBuilder("(");
        for (Class<?> param : method.getParameterTypes()) {
            builder.append(signature(param, false));
        }
        builder.append(")").append(signature(method.getReturnType(), false));
        return builder.toString();
    }

    public static void generate(Class<?> clazz, OutputStream out) throws IOException {
        if (out == null) throw new IOException("Could not write jni source code with null stream.");
        generate(clazz, new OutputStreamWriter(out));
    }

    public static void generate(Class<?> clazz, Writer out) throws IOException {
        if (out == null) throw new IOException("Could not write jni source code with null writer.");
        if (clazz == null) throw new NullPointerException("Could not generate jni source code with null class.");

        out.append("/* Generated by JNIAssist */\n");
        out.append("\n#include <jni.h>\n");

        CInclude include = clazz.getDeclaredAnnotation(CInclude.class);
        if (include != null) {
            out.append("\n");
            for (String header : include.value()) {
                String trimmed = header.trim();
                if (!(
                        (trimmed.startsWith("<") && trimmed.endsWith(">")) ||
                                (trimmed.startsWith("\"") && trimmed.endsWith("\"")))) {
                    header = "\"" + header + "\"";
                }
                out.append("#include ").append(header).append("\n");
            }
        }

        boolean firstDefined = false;
        for (Field field : clazz.getDeclaredFields()) {
            if (Modifier.isStatic(field.getModifiers())) {
                CConstantMacro constantMacro = field.getDeclaredAnnotation(CConstantMacro.class);
                if (constantMacro != null) {
                    if (!firstDefined) out.append("\n");
                    try {
                        out.append("#define ").append(field.getName()).append(" ").append(field.get(null).toString()).append("\n");
                    } catch (IllegalAccessException e) {
                        throw new IOException(e);
                    }
                    firstDefined = true;
                }
            }
        }

        out.append("\nextern JavaVM *jniassist_jvm;\n");

        for (Method method : clazz.getDeclaredMethods()) {
            if (Modifier.isStatic(method.getModifiers()) && !Modifier.isNative(method.getModifiers())) {
                CCallback callback = method.getDeclaredAnnotation(CCallback.class);
                if (callback != null) {
                    out.append("\n").append(typeMapping(method.getReturnType()));
                    out.append("\n").append(callback.value());
                    out.append("\n(");
                    Parameter[] parameters = method.getParameters();
                    String[] names = new String[parameters.length];
                    for (int i = 0; i < parameters.length; i++) {
                        CParameter parameter = parameters[i].getDeclaredAnnotation(CParameter.class);
                        if (parameter != null) {
                            if (parameter.value() != null && parameter.value().length() > 0) names[i] = parameter.value();
                        }
                    }
                    if (parameters.length > 0) {
                        for (int i = 0; i < parameters.length; i ++) {
                            if (i > 0) out.append(", ");
                            out.append(typeMapping(parameters[i].getType())).append(" ").append(names[i] == null ? "arg" + i : names[i]);
                        }
                    }
                    out.append(")\n");
                    out.append("{\nJNIEnv *env = NULL;")
                            .append("\n(*jniassist_jvm)->AttachCurrentThread(jniassist_jvm, (void **) &env, NULL);");
                    out.append("\njclass clazz = (*env)->FindClass(env, \"")
                            .append(clazz.getName().replace(".", "/"))
                            .append("\");");
                    out.append("\njmethodID methodID = (*env)->GetStaticMethodID(env, clazz, \"")
                            .append(method.getName()).append("\", \"")
                            .append(signature(method)).append("\");");
                    out.append("\n");
                    if (method.getReturnType() != void.class) out.append(typeMapping(method.getReturnType())).append(" ret = ")
                            .append("(").append(typeMapping(method.getReturnType())).append(") ");
                    out.append("(*env)->CallStatic").append(uppercase(method.getReturnType())).append("Method(env, clazz, methodID");
                    if (parameters.length > 0) {
                        for (int i = 0; i < parameters.length; i ++) {
                            out.append(", (").append(typeMapping(parameters[i].getType())).append(") ").append(names[i] == null ? "arg" + i : names[i]);
                        }
                    }
                    out.append(");")
                            .append("\n(*jniassist_jvm)->DetachCurrentThread(jniassist_jvm);");
                    if (method.getReturnType() != void.class) out.append("\nreturn ret;");
                    out.append("\n}\n");

                }
            }
        }

        for (Method method : clazz.getDeclaredMethods()) {
            if (Modifier.isNative(method.getModifiers())) {
                CFunctionBody functionBody = method.getDeclaredAnnotation(CFunctionBody.class);
                CAutoBind autoBind = method.getDeclaredAnnotation(CAutoBind.class);
                CField field = method.getDeclaredAnnotation(CField.class);
                String container = field == null ? null : field.container();
                if (container != null && container.length() < 1) {
                    if (CStruct.class.isAssignableFrom(clazz) || CUnion.class.isAssignableFrom(clazz)) {
                        container = clazz.getSimpleName();
                    }
                    else container = null;
                }
                if (functionBody != null || autoBind != null || container != null) {
                    out.append("\nJNIEXPORT ")
                            .append(typeMapping(method.getReturnType()))
                            .append(" JNICALL\n");
                    out.append("Java_")
                            .append(escapeUTF(clazz.getName().replace("_", "_1").replace(".", "_")))
                            .append("_").append(escapeUTF(method.getName().replace("_", "_1")));
                    Class<?>[] params = method.getParameterTypes();
                    if (params.length > 0) {
                        out.append("__");
                        for (Class<?> param : params) {
                            out.append(signature(param, true));
                        }
                    }
                    out.append("\n").append("(")
                            .append("JNIEnv *env, ")
                            .append(Modifier.isStatic(method.getModifiers()) ? "jclass clazz" : "jobject thiz");
                    Parameter[] parameters = method.getParameters();
                    String[] casts = new String[params.length];
                    String[] names = new String[params.length];
                    for (int i = 0; i < parameters.length; i++) {
                        CParameter parameter = parameters[i].getDeclaredAnnotation(CParameter.class);
                        if (parameter != null) {
                            if (parameter.cast() != null && parameter.cast().length() > 0) casts[i] = parameter.cast();
                            if (parameter.value() != null && parameter.value().length() > 0)
                                names[i] = parameter.value();
                        }
                    }
                    if (params.length > 0) {
                        for (int i = 0; i < params.length; i++) {
                            out.append(", ").append(typeMapping(params[i])).append(" ").append(names[i] == null ? "arg" + i : names[i]);
                        }
                    }
                    out.append(")\n");
                    out.append("{\n");
                    if (functionBody != null) out.append(functionBody.value());
                    else if (autoBind != null) {

                        boolean oneline = true;
                        List<String> c_strings = new ArrayList<>();
                        List<String> java_strings = new ArrayList<>();
                        List<String> stringTypes = new ArrayList<>();
                        for (int i = 0; i < parameters.length; i ++) {
                            CString string = parameters[i].getDeclaredAnnotation(CString.class);
                            if (params[i] == String.class && string != null) {
                                String name = string.value().length() < 1 ? "c_arg" + i : string.value();
                                out.append("const char *")
                                        .append(name)
                                        .append(" = ")
                                        .append(string.value().equalsIgnoreCase("RAW") ?
                                                "(*env)->GetStringChars(env, " : "(*env)->GetStringUTFChars(env, ")
                                        .append(names[i])
                                        .append(", JNI_FALSE")
                                        .append(");\n");
                                c_strings.add(name);
                                java_strings.add(names[i]);
                                stringTypes.add(string.value());
                                names[i] = name;
                                oneline = false;
                            }
                        }

                        CString retString = method.getDeclaredAnnotation(CString.class);
                        if (method.getReturnType() != String.class) retString = null;
                        boolean retRawString = retString != null && retString.value().equalsIgnoreCase("RAW") && retString.length().length() > 0;
                        if (retRawString) oneline = false;

                        if (oneline) {
                            if (method.getReturnType() == boolean.class) {
                                out.append("return ");
                            }
                            else if (retString != null) {
                                out.append("return (*env)->NewStringUTF(env, ");
                            }
                            else if (method.getReturnType() != void.class) {
                                out.append("return ").append("(").append(typeMapping(method.getReturnType())).append(") ");
                            }
                        }
                        else if (retRawString) {
                            out.append("const jchar *raw_str = (const jchar *) ");
                        }
                        else if (method.getReturnType() != void.class) {
                            String mapped = typeMapping(method.getReturnType());
                            out.append(mapped).append(" ret = ");
                            if (retString != null) {
                                out.append("(*env)->NewStringUTF(env, ");
                            }
                            else out.append("(").append(mapped).append(") ");
                        }

                        out.append(method.getName()).append("(");

                        if (params.length > 0) {
                            if (casts[0] != null) out.append("(").append(casts[0]).append(") ");
                            out.append(names[0] == null ? "arg0" : names[0]);
                            for (int i = 1; i < params.length; i ++) {
                                out.append(", ");
                                if (casts[i] != null) out.append("(").append(casts[i]).append(") ");
                                out.append(names[i] == null ? "arg" + i : names[i]);
                            }
                        }

                        if (method.getReturnType() == boolean.class) {
                            out.append(") ? JNI_TRUE : JNI_FALSE;");
                        }
                        else if (retRawString) {
                            out.append(");\nreturn (*env)->NewString(env, raw_str, (jsize) ")
                                    .append(retString.length()).append("(")
                                    .append(retString.cast().length() < 1 ? "" : "(" + retString.cast() + ") ")
                                    .append("raw_str));");
                        }
                        else if (retString != null) {
                            out.append("));");
                        }
                        else out.append(");");

                        if (c_strings.size() > 0) {
                            for (int i = 0; i < c_strings.size(); i ++) {
                                out.append(stringTypes.get(i).equalsIgnoreCase("RAW") ?
                                        "\n(*env)->ReleaseStringChars(env, " : "\n(*env)->ReleaseStringUTFChars(env, ")
                                        .append(java_strings.get(i))
                                        .append(", ")
                                        .append(c_strings.get(i))
                                        .append(");");
                            }
                        }

                        if (!oneline && !retRawString && method.getReturnType() != void.class) out.append("\nreturn ret;");

                    } else if (field != null) {

                        if (params.length > 0) {
                            if (method.getReturnType() == void.class) {
                                String cast = casts[1] == null ? "" : "(" + casts[1] + ") ";
                                out.append("((")
                                        .append(container)
                                        .append(" *) ")
                                        .append(names[0] == null ? "arg0" : names[0])
                                        .append(")")
                                        .append("->")
                                        .append(field.value().length() < 1 ? method.getName() : field.value())
                                        .append(" = ")
                                        .append(cast)
                                        .append(names[1] == null ? "arg1" : names[1])
                                        .append(";");
                            } else {
                                out.append("return (").append(typeMapping(method.getReturnType())).append(") ");
                                out.append("((")
                                        .append(container)
                                        .append(" *) ")
                                        .append(names[0] == null ? "arg0" : names[0])
                                        .append(")")
                                        .append("->")
                                        .append(field.value().length() < 1 ? method.getName() : field.value())
                                        .append(";");
                            }
                        }
                    }
                    out.append("\n}\n");
                }
            }
        }
        out.flush();
    }

}
