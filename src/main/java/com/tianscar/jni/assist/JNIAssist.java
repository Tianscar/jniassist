package com.tianscar.jni.assist;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;
import java.util.ArrayList;
import java.util.List;

public final class JNIAssist {

    private static String escapeUTF(String text) {
        StringBuilder builder = new StringBuilder();
        for (char ch : text.toCharArray()) {
            if (ch < 128) builder.append(ch);
            else builder.append("_0").append(Integer.toHexString(ch));
        }
        return builder.toString();
    }

    private static String typeMapping(Class<?> type) {
        if (type == void.class) return "void";
        else if (type == boolean.class) return "jboolean";
        else if (type == byte.class) return "jbyte";
        else if (type == char.class) return "jchar";
        else if (type == short.class) return "jshort";
        else if (type == int.class) return "jint";
        else if (type == long.class) return "jlong";
        else if (type == float.class) return "jfloat";
        else if (type == double.class) return "jdouble";
        else if (type == String.class) return "jstring";
        else if (Throwable.class.isAssignableFrom(type)) return "jthrowable";
        else if (Class.class.isAssignableFrom(type)) return "jclass";
        else if (type.isArray()) {
            type = type.getComponentType();
            if (type == boolean.class) return "jbooleanArray";
            else if (type == byte.class) return "jbyteArray";
            else if (type == char.class) return "jcharArray";
            else if (type == short.class) return "jshortArray";
            else if (type == int.class) return "jintArray";
            else if (type == long.class) return "jlongArray";
            else if (type == float.class) return "jfloatArray";
            else if (type == double.class) return "jdoubleArray";
            else return "jobjectArray";
        }
        else return "jobject";
    }

    private static String signature(Class<?> type, boolean escape) {
        if (type.isArray()) return (escape ? "_3" : "[") + signature(type.getComponentType(), escape);
        else if (type == void.class) return "V";
        else if (type == boolean.class) return "Z";
        else if (type == byte.class) return "B";
        else if (type == char.class) return "C";
        else if (type == short.class) return "S";
        else if (type == int.class) return "I";
        else if (type == long.class) return "J";
        else if (type == float.class) return "F";
        else if (type == double.class) return "D";
        else return "L" +
                    escapeUTF(type.getName().replace("_", "_1").replace(".", "_"))
                    + (escape ? "_2" : ";");
    }

    private static String uppercase(Class<?> type) {
        if (type == void.class) return "Void";
        else if (type == boolean.class) return "Boolean";
        else if (type == byte.class) return "Byte";
        else if (type == char.class) return "Char";
        else if (type == short.class) return "Short";
        else if (type == int.class) return "Int";
        else if (type == long.class) return "Long";
        else if (type == float.class) return "Float";
        else if (type == double.class) return "Double";
        else return "Object";
    }

    private static String signature(Method method) {
        StringBuilder builder = new StringBuilder("(");
        for (Class<?> param : method.getParameterTypes()) {
            builder.append(signature(param, false));
        }
        builder.append(")").append(signature(method.getReturnType(), false));
        return builder.toString();
    }

    private static int dimension(Class<?> array) {
        if (array.isArray()) return dimension(array.getComponentType()) + 1;
        else return 0;
    }

    private static Class<?> type(Class<?> array) {
        if (array.isArray()) return type(array.getComponentType());
        else return array;
    }

    public static void generate(Class<?> clazz, OutputStream out) throws IOException {
        if (out == null) throw new IOException("Could not write jni source code with null stream.");
        generate(clazz, new OutputStreamWriter(out));
    }

    public static void generate(Class<?> clazz, Writer out) throws IOException {
        if (out == null) throw new IOException("Could not write jni source code with null writer.");
        if (clazz == null) throw new NullPointerException("Could not generate jni source code with null class.");

        out.append("/* Generated by JNIAssist */\n");
        out.append("\n#include <jni.h>\n");
        out.append("\n#include <wchar.h>\n#include <malloc.h>\n");

        CInclude include = clazz.getDeclaredAnnotation(CInclude.class);
        if (include != null) {
            out.append("\n");
            for (String header : include.value()) {
                String trimmed = header.trim();
                if (!(
                        (trimmed.startsWith("<") && trimmed.endsWith(">")) ||
                                (trimmed.startsWith("\"") && trimmed.endsWith("\"")))) {
                    header = "\"" + header + "\"";
                }
                out.append("#include ").append(header).append("\n");
            }
        }

        boolean firstDefined = false;
        for (Field field : clazz.getDeclaredFields()) {
            if (Modifier.isStatic(field.getModifiers())) {
                CConstantMacro constantMacro = field.getDeclaredAnnotation(CConstantMacro.class);
                if (constantMacro != null) {
                    if (!firstDefined) out.append("\n");
                    try {
                        out.append("#define ").append(field.getName()).append(" ").append(field.get(null).toString()).append("\n");
                    } catch (IllegalAccessException e) {
                        throw new IOException(e);
                    }
                    firstDefined = true;
                }
            }
        }

        out.append("\nextern JavaVM *jniassist_jvm;\n");

        for (Method method : clazz.getDeclaredMethods()) {
            if (Modifier.isStatic(method.getModifiers()) && !Modifier.isNative(method.getModifiers())) {
                CCallback callback = method.getDeclaredAnnotation(CCallback.class);
                if (callback != null) {
                    out.append("\n").append(typeMapping(method.getReturnType()));
                    out.append("\n").append(callback.value());
                    out.append("\n(");
                    Parameter[] parameters = method.getParameters();
                    String[] names = new String[parameters.length];
                    for (int i = 0; i < parameters.length; i++) {
                        CParameter parameter = parameters[i].getDeclaredAnnotation(CParameter.class);
                        if (parameter != null) {
                            if (parameter.value() != null && parameter.value().length() > 0) names[i] = parameter.value();
                        }
                    }
                    if (parameters.length > 0) {
                        for (int i = 0; i < parameters.length; i ++) {
                            if (i > 0) out.append(", ");
                            out.append(typeMapping(parameters[i].getType())).append(" ").append(names[i] == null ? "arg" + i : names[i]);
                        }
                    }
                    out.append(")\n");
                    out.append("{\nJNIEnv *env = NULL;")
                            .append("\n(*jniassist_jvm)->AttachCurrentThread(jniassist_jvm, (void **) &env, NULL);");
                    out.append("\njclass clazz = (*env)->FindClass(env, \"")
                            .append(clazz.getName().replace(".", "/"))
                            .append("\");");
                    out.append("\njmethodID methodID = (*env)->GetStaticMethodID(env, clazz, \"")
                            .append(method.getName()).append("\", \"")
                            .append(signature(method)).append("\");");
                    out.append("\n");
                    if (method.getReturnType() != void.class) out.append(typeMapping(method.getReturnType())).append(" ret = ")
                            .append("(").append(typeMapping(method.getReturnType())).append(") ");
                    out.append("(*env)->CallStatic").append(uppercase(method.getReturnType())).append("Method(env, clazz, methodID");
                    if (parameters.length > 0) {
                        for (int i = 0; i < parameters.length; i ++) {
                            out.append(", (").append(typeMapping(parameters[i].getType())).append(") ").append(names[i] == null ? "arg" + i : names[i]);
                        }
                    }
                    out.append(");")
                            .append("\n(*jniassist_jvm)->DetachCurrentThread(jniassist_jvm);");
                    if (method.getReturnType() != void.class) out.append("\nreturn ret;");
                    out.append("\n}\n");

                }
            }
        }

        for (Method method : clazz.getDeclaredMethods()) {
            if (Modifier.isNative(method.getModifiers())) {
                CFunctionBody functionBody = method.getDeclaredAnnotation(CFunctionBody.class);
                CAutoBind autoBind = method.getDeclaredAnnotation(CAutoBind.class);
                CField field = method.getDeclaredAnnotation(CField.class);
                String container = field == null ? null : field.container();
                if (container != null && container.length() < 1) {
                    if (CStruct.class.isAssignableFrom(clazz) || CUnion.class.isAssignableFrom(clazz)) {
                        container = clazz.getSimpleName();
                    }
                    else container = null;
                }
                if (functionBody != null || autoBind != null || container != null) {
                    out.append("\nJNIEXPORT ")
                            .append(typeMapping(method.getReturnType()))
                            .append(" JNICALL\n");
                    out.append("Java_")
                            .append(escapeUTF(clazz.getName().replace("_", "_1").replace(".", "_")))
                            .append("_").append(escapeUTF(method.getName().replace("_", "_1")));
                    Class<?>[] params = method.getParameterTypes();
                    if (params.length > 0) {
                        out.append("__");
                        for (Class<?> param : params) {
                            out.append(signature(param, true));
                        }
                    }
                    out.append("\n").append("(")
                            .append("JNIEnv *env, ")
                            .append(Modifier.isStatic(method.getModifiers()) ? "jclass clazz" : "jobject thiz");
                    Parameter[] parameters = method.getParameters();
                    String[] casts = new String[params.length];
                    String[] names = new String[params.length];
                    for (int i = 0; i < parameters.length; i++) {
                        CParameter parameter = parameters[i].getDeclaredAnnotation(CParameter.class);
                        if (parameter != null) {
                            if (parameter.cast() != null && parameter.cast().length() > 0) casts[i] = parameter.cast();
                            if (parameter.value() != null && parameter.value().length() > 0)
                                names[i] = parameter.value();
                        }
                        if (names[i] == null || names[i].length() < 1) names[i] = "arg" + i;
                    }
                    if (params.length > 0) {
                        for (int i = 0; i < params.length; i++) {
                            out.append(", ").append(typeMapping(params[i])).append(" ").append(names[i]);
                        }
                    }
                    out.append(")\n");
                    out.append("{\n");
                    if (functionBody != null) out.append(functionBody.value());
                    else if (autoBind != null) {

                        boolean oneline = true;
                        List<String> c_strings = new ArrayList<>();
                        List<String> strings = new ArrayList<>();
                        List<String> stringTypes = new ArrayList<>();
                        List<String> c_arrays = new ArrayList<>();
                        List<String> arrays = new ArrayList<>();
                        List<String> arrayTypes = new ArrayList<>();
                        List<Integer> arrayDimensions = new ArrayList<>();
                        for (int i = 0; i < parameters.length; i ++) {
                            CString string = parameters[i].getDeclaredAnnotation(CString.class);
                            if (params[i] == String.class && string != null) {
                                String name = "c_" + names[i];
                                out.append("const char *")
                                        .append(name)
                                        .append(" = ")
                                        .append(string.value().equalsIgnoreCase("JCHAR") ?
                                                "(*env)->GetStringChars(env, " : "(*env)->GetStringUTFChars(env, ")
                                        .append(names[i])
                                        .append(", JNI_FALSE")
                                        .append(");\n");
                                c_strings.add(name);
                                strings.add(names[i]);
                                stringTypes.add(string.value());
                                names[i] = name;
                                oneline = false;
                            }
                        }
                        for (int i = 0; i < parameters.length; i ++) {
                            if (params[i].isArray()) {
                                String name = "c_" + names[i];
                                c_arrays.add(name);
                                arrays.add(names[i]);
                                int arrayDimension = dimension(params[i]);
                                arrayDimensions.add(arrayDimension);
                                if (arrayDimension == 1) {
                                    String arrayType = uppercase(params[i].getComponentType());
                                    out.append(typeMapping(params[i].getComponentType())).append(" *")
                                            .append(name)
                                            .append(" = ")
                                            .append("(*env)->Get")
                                            .append(arrayType)
                                            .append("ArrayElements(env, ")
                                            .append(names[i])
                                            .append(", NULL);\n");
                                    arrayTypes.add(arrayType);
                                }
                                else {
                                    for (int d = 0; d < arrayDimension - 1; d ++) {
                                        String n = name + "_len_" + d;
                                        out.append("jsize ")
                                                .append(n)
                                                .append(" = (*env)->GetArrayLength(env, ");
                                        if (d == 0) out.append(names[i]).append(");\n");
                                        else {
                                            for (int e = arrayDimension - d; e < arrayDimension; e ++) {
                                                out.append("(*env)->GetObjectArrayElement(env, ");
                                            }
                                            for (int e = arrayDimension - d; e < arrayDimension; e ++) {
                                                if (e == arrayDimension - d) out.append("arr, 0)");
                                                else out.append(", 0)");
                                            }
                                            out.append(");\n");
                                        }
                                    }
                                    Class<?> type = type(params[i]);
                                    String arrayType = uppercase(type);
                                    out.append(typeMapping(type)).append(" ");
                                    for (int d = 0; d < arrayDimension; d ++) {
                                        out.append("*");
                                    }
                                    out.append(name)
                                            .append(" = malloc(")
                                            .append(name).append("_len_0")
                                            .append(" * sizeof(void *));\n");
                                    StringBuilder acc_builder = new StringBuilder();
                                    for (int d = 0; d < arrayDimension - 1; d ++) {
                                        out.append("for (jsize i_").append(String.valueOf(d)).append(" = 0; ")
                                                        .append("i_").append(String.valueOf(d)).append(" < ")
                                                        .append(name).append("_len_").append(String.valueOf(d)).append("; ")
                                                        .append("i_").append(String.valueOf(d)).append(" ++) {\n");
                                        acc_builder.append("[i_").append(d).append("]");
                                        out.append(name).append(acc_builder).append(" = ");
                                        if (d < arrayDimension - 2) {
                                            out.append("malloc(")
                                                    .append(name).append("_len_").append(String.valueOf(d)).append(" * sizeof(void *));\n");
                                        }
                                        else out.append("(*env)->Get").append(arrayType).append("ArrayElements(\n");
                                    }
                                    for (int d = 0; d < arrayDimension - 1; d ++) {
                                        out.append("env, (*env)->GetObjectArrayElement(\n");
                                    }
                                    out.append("env, ").append(names[i]);
                                    for (int d = 0; d < arrayDimension - 1; d ++) {
                                        out.append(", i_").append(String.valueOf(d)).append(")");
                                    }
                                    out.append(", NULL);\n");
                                    for (int d = 0; d < arrayDimension - 1; d ++) {
                                        out.append("}");
                                    }
                                    out.append("\n");
                                    arrayTypes.add(arrayType);
                                }
                                names[i] = name;
                                oneline = false;
                            }
                        }

                        CString ret_string = method.getDeclaredAnnotation(CString.class);
                        if (method.getReturnType() != String.class) ret_string = null;
                        boolean ret_jchar_string = ret_string != null && ret_string.value().equalsIgnoreCase("JCHAR") && ret_string.length().length() > 0;
                        if (ret_jchar_string) oneline = false;

                        if (oneline) {
                            if (method.getReturnType() == boolean.class) {
                                out.append("return ");
                            }
                            else if (ret_string != null) {
                                out.append("return (*env)->NewStringUTF(env, ");
                            }
                            else if (method.getReturnType() != void.class) {
                                out.append("return ").append("(").append(typeMapping(method.getReturnType())).append(") ");
                            }
                        }
                        else if (ret_jchar_string) {
                            out.append("const jchar *jchar_str = (const jchar *) ");
                        }
                        else if (method.getReturnType() != void.class) {
                            String mapped = typeMapping(method.getReturnType());
                            out.append(mapped).append(" ret = ");
                            if (ret_string != null) {
                                out.append("(*env)->NewStringUTF(env, ");
                            }
                            else out.append("(").append(mapped).append(") ");
                        }

                        out.append(method.getName()).append("(");

                        if (params.length > 0) {
                            if (casts[0] != null) out.append("(").append(casts[0]).append(") ");
                            out.append(names[0]);
                            for (int i = 1; i < params.length; i ++) {
                                out.append(", ");
                                if (casts[i] != null) out.append("(").append(casts[i]).append(") ");
                                out.append(names[i]);
                            }
                        }

                        if (method.getReturnType() == boolean.class) out.append(") ? JNI_TRUE : JNI_FALSE;");
                        else if (ret_jchar_string) {
                            out.append(");\nreturn (*env)->NewString(env, jchar_str, (jsize) ")
                                    .append(ret_string.length()).append("(")
                                    .append(ret_string.cast().length() < 1 ? "" : "(" + ret_string.cast() + ") ")
                                    .append("jchar_str));");
                        }
                        else if (ret_string != null) out.append("));");
                        else out.append(");");

                        if (c_strings.size() > 0) {
                            for (int i = 0; i < c_strings.size(); i ++) {
                                out.append(stringTypes.get(i).equalsIgnoreCase("JCHAR") ?
                                        "\n(*env)->ReleaseStringChars(env, " : "\n(*env)->ReleaseStringUTFChars(env, ")
                                        .append(strings.get(i))
                                        .append(", ")
                                        .append(c_strings.get(i))
                                        .append(");");
                            }
                        }

                        if (c_arrays.size() > 0) {
                            for (int i = 0; i < c_arrays.size(); i ++) {
                                if (arrayDimensions.get(i) == 1) {
                                    out.append("\n(*env)->Release")
                                            .append(arrayTypes.get(i))
                                            .append("ArrayElements(env, ")
                                            .append(arrays.get(i))
                                            .append(", ")
                                            .append(c_arrays.get(i))
                                            .append(", JNI_FALSE);");
                                }
                                else {
                                    int arrayDimension = arrayDimensions.get(i);
                                    String name = c_arrays.get(i);
                                    StringBuilder acc_builder = new StringBuilder();
                                    out.append("\n");
                                    for (int d = 0; d < arrayDimension - 1; d ++) {
                                        out.append("for (jsize i_").append(String.valueOf(d)).append(" = 0; ")
                                                .append("i_").append(String.valueOf(d)).append(" < ")
                                                .append(name).append("_len_").append(String.valueOf(d)).append("; ")
                                                .append("i_").append(String.valueOf(d)).append(" ++) {\n");
                                        acc_builder.append("[i_").append(d).append("]");
                                    }
                                    out.append("(*env)->Release").append(arrayTypes.get(i)).append("ArrayElements(\n");
                                    for (int d = 0; d < arrayDimension - 1; d ++) {
                                        out.append("env, (*env)->GetObjectArrayElement(\n");
                                    }
                                    out.append("env, ").append(arrays.get(i));
                                    for (int d = 0; d < arrayDimension - 1; d ++) {
                                        out.append(", i_").append(String.valueOf(d)).append(")");
                                    }
                                    out.append(", ").append(name).append(acc_builder).append(", JNI_FALSE);");
                                    String acc = acc_builder.toString();
                                    for (int d = 0; d < arrayDimension - 1; d ++) {
                                        out.append("\n}\nfree(").append(name).append(acc = acc.substring(0, acc.lastIndexOf("["))).append(");");
                                    }
                                }
                            }
                        }

                        if (!oneline && !ret_jchar_string && method.getReturnType() != void.class) out.append("\nreturn ret;");

                    } else if (field != null) {

                        if (params.length > 0) {
                            if (method.getReturnType() == void.class) {
                                String cast = casts[1] == null ? "" : "(" + casts[1] + ") ";
                                out.append("((")
                                        .append(container)
                                        .append(" *) ")
                                        .append(names[0])
                                        .append(")")
                                        .append("->")
                                        .append(field.value().length() < 1 ? method.getName() : field.value())
                                        .append(" = ")
                                        .append(cast)
                                        .append(names[1])
                                        .append(";");
                            } else {
                                out.append("return (").append(typeMapping(method.getReturnType())).append(") ");
                                out.append("((")
                                        .append(container)
                                        .append(" *) ")
                                        .append(names[0])
                                        .append(")")
                                        .append("->")
                                        .append(field.value().length() < 1 ? method.getName() : field.value())
                                        .append(";");
                            }
                        }
                    }
                    out.append("\n}\n");
                }
            }
        }
        out.flush();
    }

}
